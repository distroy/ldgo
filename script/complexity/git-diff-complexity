#! /usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) distroy
#

import traceback
import os
import io
import time
import sys
import optparse
import typing

from core import log
from core import exec
from core import git
from core import complexity

# sys.path.insert(0, os.path.dirname(os.path.realpath(__file__)))


def get_options() -> tuple[optparse.Values, list[typing.Any]]:
    parser = optparse.OptionParser(version="%prog (distroy) 0.1")

    parser.add_option('-c', '--cogntive', dest='cogntive', metavar='<cogntive>',
                      default=15, type='int', help='cogntive complexity threshold. default: 15')
    parser.add_option('-e', '--exclude', dest='excludes', metavar='<regexp>',
                      default=[], action='append', help='exclude pathes')
    parser.add_option('-i', '--include', dest='includes', metavar='<regexp>',
                      default=[], action='append', help='include pathes')

    opts, args = parser.parse_args()
    return opts, args


def get_branch(args:  list[str]) -> str:
    if len(args) > 0 and args[0] != '':
        return args[0]
    return git.get_branch()


def wrapper_diffs(diffs: list[git.Diff]) -> typing.Callable[[git.Diff], bool]:
    file_diffs: dict[str, list[git.Diff]] = {}
    for diff in diffs:
        if diff.file not in file_diffs:
            file_diffs[diff.file] = []
        file_diffs[diff.file].append(diff)
    # print(file_diffs)

    def handler(v: git.Diff) -> bool:
        if v.file not in file_diffs:
            return False
        for df in file_diffs[v.file]:
            if v.end < df.pos or v.pos > df.end:
                continue
            # print('diff:', df, 'complexities:', v)
            return True
        return False

    return handler


def main(opts: optparse.Values, args: list[str]):
    repo_root = git.repo_root()
    branch = get_branch(args)

    diffs = git.get_diffs(branch)

    cplxes = complexity.get_cogntive(repo_root, threshold=opts.cogntive,
                                     excludes=opts.excludes, includes=opts.includes)
    # print('%s' % complexities)
    # print([str(i) for i in complexities])

    fn = wrapper_diffs(diffs)
    new_cplxes: list[complexity.Complexity] = []
    old_cplxes: list[complexity.Complexity] = []
    for cplx in cplxes:
        if fn(git.Diff(cplx.file, pos=cplx.pos, end=cplx.end)):
            new_cplxes.append(cplx)
        else:
            old_cplxes.append(cplx)

    if len(new_cplxes) > 0:
        f = sys.stderr
        f.write(log.Color.FG_R)
        f.write('The cogntive complexity of these *new* functions is too high (over %d): \n' %
                (opts.cogntive))
        for cplx in new_cplxes:
            f.write('%s\n' % str(cplx))
        f.write(log.Color.RESET)
        f.write('\n')

    if len(old_cplxes) > 0:
        count = 10
        if len(old_cplxes) > count:
            old_cplxes = old_cplxes[:count]
        f = sys.stdout
        f.write(log.Color.FG_G)
        f.write('The cogntive complexity of these *old* functions is too high (over %d): \n' %
                (opts.cogntive))
        f.write(log.Color.RESET)
        for cplx in old_cplxes:
            f.write('%s\n' % str(cplx))
        f.write('\n')

    return 0 if len(new_cplxes) == 0 else 1


if __name__ == "__main__":
    try:
        (opts, args) = get_options()
        exit(main(opts, args))
    except KeyboardInterrupt:
        sys.stderr.write("\033[1;31moperation cancelled by user\033[0m\n")
        exit(-1)
    except Exception:
        sys.stderr.write(traceback.format_exc())
        exit(-1)
